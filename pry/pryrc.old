# === EDITOR ===
Pry.editor = 'nvim'
#https://gist.github.com/bespokoid/3732620
#https://github.com/lebibin/dotfiles
#
# === THEME ===
class Dracula
    attr_accessor :readline_mode

    def initialize
        @readline_mode = false
    end

    def method_missing(method, *args, &block)
        proxy = TTYProxy.new()
        if proxy.respond_to?(method)
            proxy.send(method, *args, &block)
            return proxy
        end
        raise
    end

    class TTYProxy
        @@attr_codes = {
            bold: 1,
            underline: 4,
            italic: 3
        }
        def initialize
            @colors = {
                green: "80;250;123",
                cyan: "102;217;239",
                pink: "255;121;198",
                purple: "189;147;249",
                white: "248;248;242",
                red: "255;85;85",
                orange: "255;184;108",
                yellow: "241;250;140",
                comment: "98;114;164"
            }
            @fg = nil
            @bg = nil
            @attrs = {bold: false, underline: false, italic: false}
            @colors.each_key do |color|
                self.class.send(:define_method, color) do
                    @fg = color
                    return self
                end
                self.class.send(:define_method, color.to_s + "_bg") do
                    @bg = color
                    return self
                end

            end
            @attrs.each_key do |attrib|
                self.class.send(:define_method, attrib) do |set=true|
                    @attrs[attrib] = set
                    return self
                end
            end
        end

        def to_s
            fg_color = @colors.fetch(@fg,nil) ? "38;2;#{@colors[@fg]}" : nil
            bg_color = @colors.fetch(@bg,nil) ? "48;2;#{@colors[@bg]}" : nil
            attibs = @attrs.map { |a,set| set ? @@attr_codes[a] : nil }.compact.join(";") || nil
            return "#{@readline_mode ? "\001" : ''}\e[0;" + \
                    [fg_color,bg_color,attibs].compact.join(";").gsub(/;$/,'') + "m" + \
                    (@readline_mode ? "\002" : '')
        end

        def reset
            @fg = nil
            @bg = nil
            @attrs.each { |k,_| @attrs[k] = false }
            return %Q!#{@readline_mode ? "\001" : ''}\e[0m#{@readline_mode ? "\002" : ''}!
        end

    end
end

CodeRay.scan("ruby", :ruby).term # preload files

module CodeRay
    module Encoders
        class Terminal < Encoder
            cs = Dracula.new()
            {
                :symbol => cs.purple,               # :symbols
                :ident  => cs.white,                    # default
                :debug => cs.red_bg,                    # not used?
                :binary => {                            # not implemented
                    :self => cs.purple,
                    :char => "",
                    :delimiter => "",
                },
                :key => {
                    :self => cs.purple,             # symbols only
                    :delimiter => cs.white,
                },
                :instance_variable => cs.purple.italic, # @instance_var
                :class => cs.cyan.bold.italic,          # class name
                :class_variable => cs.cyan.italic,      # @@classvar
                :comment => {
                    :self => cs.comment.italic,         # just like this…
                    :char => "",
                    :delimiter => "",
                },
                :operator => cs.pink,                   # == => . ||= &&
                :constant => cs.cyan.bold.italic,       # CONSTANT
                :doctype => cs.pink,                    # shbang
                :error => cs.red,                       # $^
                :float => cs.purple,                    # 3.14
                :method => cs.green.bold,               # method name
                :global_variable => cs.purple,          # $var
                :hex => cs.purple,                      # not implemented
                :integer => cs.purple,                  # 0xF,0o1,0b1 & int
                :octal => cs.purple,                    # not implemented
                :regexp => {
                    :self => "",                        # /[A-Z]/
                    :delimiter => "",                   # the /'s
                    :modifier => "",                    # multiline, etc.
                    :char => "",                        # escaped characters
                },
                :keyword => cs.pink,                    # return, if, raise, …
                :shell => {
                    :self => "",                        # `shell commands`
                    :char => "",                        # \e\n\001\u
                    :delimiter => "",                   # the backticks
                    :escape => "c",                     # `#$var #@var`
                    :inline => "***",                   # `#{var}`
                    :inline_delimiter => "\e[1m"        # the #{  and  }
                },
                :string => {
                    :self => cs.yellow,                 # the base string
                    :char => cs.pink,                   # \e\n\1\u3434
                    :delimiter => cs.yellow.bold,       # the "
                    :escape => cs.pink,                 # "#$var #@var"
                    :inline => cs.reset,                # doesn't work?
                    #XXX inline should be tokenized. Not supported by CodeRay
                    :inline_delimiter => cs.pink        # the #{ } from inline
                }
            }.each_pair do |key, value|
                if value.is_a?(Hash) then
                    value.each { |k,c| value[k] = c.to_s }
                else
                    value = value.to_s
                end
                TOKEN_COLORS[key] = value
            end
            old_text_token = instance_method(:text_token)
            define_method(:text_token) do |text,kind|
                #puts "'#{text}'"
                if (kind == :operator && ( text == "," or text == "(" or text == ")" ) ) then
                    kind = :ident
                end
                old_text_token.bind(self).(text,kind)
            end
        end
    end
end

# === COLORS ===
unless ENV['PRY_BW']
  Pry.color = true
  #Pry.config.theme = "railscasts"
  Pry.config.prompt = PryRails::RAILS_PROMPT if defined?(PryRails::RAILS_PROMPT)
  Pry.config.prompt ||= Pry.prompt
end

# === HISTORY ===
Pry::Commands.command /^$/, "repeat last command" do
  _pry_.run_command Pry.history.to_a.last
end

# == Pry-Nav - Using pry as a debugger ==
Pry.commands.alias_command 'c', 'continue' rescue nil
Pry.commands.alias_command 's', 'step' rescue nil
Pry.commands.alias_command 'n', 'next' rescue nil
Pry.commands.alias_command 'f', 'finish' rescue nil
Pry.commands.alias_command 'l', 'whereami' rescue nil

# === Listing config ===
# Better colors - by default the headings for methods are too
# similar to method name colors leading to a "soup"
# These colors are optimized for use with Solarized scheme
# for your terminal
Pry.config.ls.separator = "\n" # new lines between methods
Pry.config.ls.heading_color = :magenta
Pry.config.ls.public_method_color = :green
Pry.config.ls.protected_method_color = :yellow
Pry.config.ls.private_method_color = :bright_black

# == PLUGINS ===
# amazing_print gem: great syntax colorized printing
begin
  require 'amazing_print'
  # The following line enables amazing_print for all pry output,
  # and it also enables paging
  Pry.config.print = proc { |output, value| Pry::Helpers::BaseHelpers.stagger_output("=> #{value.ai}", output) }

  # If you want awesome_print without automatic pagination, use the line below
  module AmazingPrint
    Formatter.prepend(Module.new do
      def awesome_self(object, type)
        if type == :string && @options[:string_limit] && object.inspect.to_s.length > @options[:string_limit]
          colorize(object.inspect.to_s[0..@options[:string_limit]] + "...", type)
        else
          super(object, type)
        end
      end
    end)
  end

  AmazingPrint.defaults = {
    :string_limit => 80,
    :indent => 2,
    :multiline => true
  }
  AmazingPrint.pry!
rescue LoadError => err
  puts "gem install amazing_print  # <-- highly recommended"
end

# === CUSTOM COMMANDS ===
default_command_set = Pry::CommandSet.new do
  command "sql", "Send sql over AR." do |query|
    if ENV['RAILS_ENV'] || defined?(Rails)
      pp ActiveRecord::Base.connection.select_all(query)
    else
      pp "No rails env defined"
    end
  end
end

Pry.config.commands.import default_command_set

# === COLOR CUSTOMIZATION ===
# Everything below this line is for customizing colors, you have to use the ugly
# color codes, but such is life.
CodeRay.scan("example", :ruby).term # just to load necessary files
# Token colors pulled from: https://github.com/rubychan/coderay/blob/master/lib/coderay/encoders/terminal.rb

$LOAD_PATH << File.dirname(File.realpath(__FILE__))


PRY_BUMMERS = []

%w(
  hirb
  amazing_print
  amazing_print/ext/active_record
  amazing_print/ext/active_support
).each do |gem|
  begin
    require gem
  rescue LoadError
    PRY_BUMMERS << gem
  end
end

Pry.editor = 'vim'
Pry.config.pager = true
Pry.config.should_load_local_rc = defined?(Rails) || Dir.pwd != Dir.home


#Support XDG data location for history if env set
if ENV.include?('XDG_DATA_HOME')
    history_file = "~/.local/share/pry/pry_history"
    dir = File.dirname(history_file)
    FileUtils.mkdir_p dir unless Dir.exist? dir
    Pry.config.should_load_rc = false
    Pry.config.should_load_local_rc = false
    history_file_path = File.expand_path(history_file)
    Pry.config.history_file = history_file_path
end

cs = Dracula.new()
cs.readline_mode = true


# === PROMPT ===
#Pry.prompt = [ ->(obj, nest_level, _) { "✎ " }, ->(obj, nest_level, _) { "#{' ' * nest_level}  " } ]
unless false
    default_prompt = Pry::Prompt[:default]
    env = "" #Pry::Helpers::Text.red(Rails.env.upcase)
    Pry.config.prompt = Pry::Prompt.new(
      'custom',
      'my custom prompt',
      [ proc { "PRY #{cs.green}❯#{cs.reset} " }, proc { " * #{cs.green.italic}>>#{cs.reset} " }]
    #   [
    #     proc{ |*args| "#{env} #{default_prompt.wait_proc.call(*args)}" },
    #     proc{ |*args| "#{env} #{default_prompt.incomplete_proc.call(*args)}" },
    #   ],
    )
  end

def pager!
    Pry.config.pager = !Pry.config.pager
    Hirb.enable :pager => Pry.config.pager if defined?(Hirb)
end

if defined?(Hirb) then
    Hirb.enable
    def hirb!
        if Hirb::View.toggle_formatter
            Hirb.enable :pager => Pry.config.pager
        else
            Hirb.enable :pager => false
            false
        end
    end
end

if defined?(Rails) && Rails.version.to_f >= 3.0
    #a quick alias for reload!
    def r!
      reload!
    end

    # Should disable by default TODO
    # automatically reload rails env every time a new command is typed
    Pry.hooks.add_hook(:before_eval, :reload_everything) { reload!(false) }
end

# https://gist.github.com/lfender6445/9919357
# PRY CHEAT SHEET

# Welcome message.
Pry.hooks.add_hook(:before_session, "pryrc_start_hook") do |output, binding, pry|
    puts "" unless defined?(Rails) #Add a linebreak if not in rails console
    ruby_version =
        if defined? RUBY_VERSION && defined? RUBY_PATCHLEVEL
            "#{RUBY_VERSION}-p#{RUBY_PATCHLEVEL}"
        elsif defined? RUBY_DESCRIPTION
            RUBY_DESCRIPTION.split(' ')[1].sub('p', '-p')
        else
            (`ruby -v` || '').split(' ')[1].sub('p', '-p')
        end
    output.print "Pry session running on #{cs.red} #{ruby_version}#{cs.reset} "
    output.print "with RubyGems #{Gem::VERSION}" if defined? Gem::VERSION
    output.puts "."
    output.puts "#{cs.red}Opps! Unable to load gems: #{PRY_BUMMERS.join ', '}" unless PRY_BUMMERS.empty?
    output.puts cs.reset
end

# coding:utf-8 vim:ft=ruby
if defined?(ActiveRecord) then
    # [] acts as find()
    ActiveRecord::Base.instance_eval { alias :[] :find } if defined?(ActiveRecord)
end
